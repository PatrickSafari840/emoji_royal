<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Emoji Mayhem</title>
    <!-- NEW: Added PeerJS library for networking -->
    <script src="peer.min.js"></script>
    <style>
        /* --- GLOBAL STYLES & SETUP --- */
        :root {
            --font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            --text-light: #f0f0f0;
            --text-dark: #222;
            --ui-bg: rgba(0, 0, 0, 0.7);
            --border-radius: 8px;
            --blue-team-color: #007bff;
            --red-team-color: #dc3545;
            --monster-color: #9400d3;
            --health-green: #28a745;
            --health-yellow: #ffc107;
            --health-red: #dc3545;
            --shield-color: #00c4ff;
        }

        /* Map Themes - This system makes adding new maps trivial */
        .theme-cyber { --bg-color: #0d0221; --obstacle-color: #2de2e6; --zone-color: rgba(240, 5, 221, 0.2); }
        .theme-inferno { --bg-color: #2a0000; --obstacle-color: #ff4500; --zone-color: rgba(255, 140, 0, 0.2); }
        .theme-toxic { --bg-color: #2f3d02; --obstacle-color: #abff00; --zone-color: rgba(128, 255, 0, 0.2); }
        .theme-ocean { --bg-color: #001f3f; --obstacle-color: #7FDBFF; --zone-color: rgba(0, 116, 217, 0.2); }
        .theme-candy { --bg-color: #fff0f5; --obstacle-color: #ffc0cb; --zone-color: rgba(255, 105, 180, 0.2); }
        .theme-jungle { --bg-color: #003e00; --obstacle-color: #228B22; --zone-color: rgba(124, 252, 0, 0.2); }
        .theme-mono { --bg-color: #111; --obstacle-color: #ccc; --zone-color: rgba(255, 255, 255, 0.2); }
        .theme-desert { --bg-color: #f4a460; --obstacle-color: #8b4513; --zone-color: rgba(255, 69, 0, 0.2); }
        .theme-royal { --bg-color: #4b0082; --obstacle-color: #ffd700; --zone-color: rgba(218, 165, 32, 0.2); }
        .theme-ghostly { --bg-color: #2d2d2d; --obstacle-color: #a2fafa; --zone-color: rgba(255, 255, 255, 0.2); }

        @keyframes pulseGlow {
            0% { text-shadow: 0 0 8px var(--obstacle-color); }
            50% { text-shadow: 0 0 20px var(--obstacle-color); }
            100% { text-shadow: 0 0 8px var(--obstacle-color); }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            overflow: hidden;
            color: var(--text-light);
            background-color: var(--bg-color); /* Default theme background */
            transition: background-color 0.5s ease;
            user-select: none; /* Prevents annoying text selection during gameplay */
        }
        
        #game-container {
             transition: transform 0.1s ease-out; /* For screen shake */
        }

        canvas#game-canvas { /* Be specific */
            position: absolute;
            top: 0;
            left: 0;
            background-color: var(--bg-color);
            z-index: 1;
        }

        /* --- UI SCREENS (MENU, GAME OVER) --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            z-index: 100;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .screen h1 {
            font-size: 5rem;
            animation: pulseGlow 4s infinite;
        }

        .screen h2 {
            font-size: 3rem;
            margin-bottom: 20px;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
        }
        
        .multiplayer-section, .solo-section {
            border: 1px solid var(--obstacle-color);
            padding: 20px;
            border-radius: var(--border-radius);
            width: 400px;
            max-width: 90vw;
        }
        
        .multiplayer-section h3, .solo-section h3 {
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .join-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        #join-id-input {
            flex-grow: 1;
            font-size: 1.2rem;
            padding: 10px;
            background: rgba(0,0,0,0.4);
            border: 1px solid #555;
            color: var(--text-light);
            border-radius: 5px;
        }

        #my-peer-id-display {
            margin-top: 15px;
            font-size: 1.2rem;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            min-height: 45px;
        }
        
        #my-peer-id-display span {
            font-weight: bold;
            color: var(--obstacle-color);
            cursor: pointer;
            word-break: break-all;
        }

        .play-button {
            font-size: 1.5rem;
            padding: 10px 25px;
            border-radius: var(--border-radius);
            border: 2px solid var(--obstacle-color);
            background-color: transparent;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .play-button:hover {
            background-color: var(--obstacle-color);
            color: var(--text-dark);
            box-shadow: 0 0 20px var(--obstacle-color);
            transform: scale(1.05);
        }
        .play-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            background-color: transparent;
            color: var(--text-light);
        }
        
        /* --- IN-GAME HUD --- */
        #hud {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 2;
        }

        .hud-element {
            background: var(--ui-bg);
            border-radius: var(--border-radius);
            padding: 10px 15px;
            backdrop-filter: blur(5px);
        }

        #team-info {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .team-member {
            display: flex;
            align-items: center;
            gap: 10px;
            transition: opacity 0.3s ease;
        }
        
        .team-member.player-is-you {
            border: 1px solid var(--obstacle-color);
            padding: 5px;
            margin: -5px; /* Compensate for border */
            border-radius: 5px;
        }

        .team-member.eliminated {
            opacity: 0.4;
            text-decoration: line-through;
        }
        
        .health-shield-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .bar {
            width: 100px;
            height: 8px;
            background-color: #444;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #222;
        }
        .bar-inner {
            height: 100%;
            transition: width 0.2s linear, background-color 0.3s ease;
        }
        #health-bar-inner { background-color: var(--health-green); }
        #shield-bar-inner { background-color: var(--shield-color); }
        
        #ammo-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 2rem;
            font-weight: bold;
            text-align: right;
        }
        #ammo-info.reloading {
             color: var(--health-red);
             animation: pulseGlow 1s infinite;
        }
        
        #minimap-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            border: 2px solid var(--obstacle-color);
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        #minimap-canvas {
            display: block;
        }
        
        #match-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 1.2rem;
        }

        /* --- NEW: TOUCH CONTROLS (Mobile) --- */
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: none; /* Container doesn't block events, only children do */
            display: none; /* Hidden by default */
        }

        .touch-enabled #touch-controls {
            display: block;
        }

        .joystick {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none; /* Initially hidden, shown on touch */
            pointer-events: none; /* Visual only, doesn't capture events */
        }

        .joystick-nub {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(0, 0); /* JS will update this */
        }

        #reload-button {
            position: absolute;
            bottom: 180px;
            right: 50px;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-light);
            pointer-events: auto; /* This button IS clickable */
            user-select: none;
        }
        #reload-button:active {
            background: rgba(255, 255, 255, 0.4);
        }
        
        @media (max-width: 768px), (max-height: 500px) {
            #minimap-container, #ammo-info {
                display: none;
            }
        }
    </style>
</head>
<body class="theme-cyber">
    <!-- Game Screens -->
    <div id="menu-screen" class="screen">
        <h1>âœ¨ Emoji Mayhem âœ¨</h1>
        
        <!-- MODIFIED: Menu now has multiplayer/solo options -->
        <div class="menu-options">
            <div class="multiplayer-section">
                <h3>ðŸ‘¥ Multiplayer</h3>
                <button id="create-game-btn" class="play-button">Create Game</button>
                <div id="my-peer-id-display">Waiting for ID...</div>
                <div class="join-group">
                    <input type="text" id="join-id-input" placeholder="Enter friend's ID">
                    <button id="join-game-btn" class="play-button">Join</button>
                </div>
            </div>
            
            <div class="solo-section">
                <h3>ðŸ‘¤ Solo Play</h3>
                <p style="font-size: 0.9rem; margin: 0 0 15px 0;">Play alone against AI bots.</p>
                <button id="play-solo-btn" class="play-button">Play Solo</button>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h2 id="game-over-title">VICTORY ROYALE!</h2>
        <p id="game-over-message">Your team wiped out the competition!</p>
        <button id="play-again-button" class="play-button">Play Again</button>
    </div>

    <!-- Main Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="team-info" class="hud-element">
                <!-- Team info will be dynamically generated by JS -->
            </div>
            <div id="match-info" class="hud-element">
                <div>Players Left: <span id="players-left">8</span></div>
                <div>Zone Shrinks In: <span id="zone-timer">--</span></div>
            </div>
            <div id="ammo-info" class="hud-element">
                <span id="ammo-count">--</span>
            </div>
            <div id="minimap-container">
                <canvas id="minimap-canvas" width="200" height="200"></canvas>
            </div>
            
            <div id="touch-controls">
                <div id="joystick-move" class="joystick"><div class="joystick-nub"></div></div>
                <div id="joystick-aim" class="joystick"><div class="joystick-nub"></div></div>
                <div id="reload-button">R</div>
            </div>
        </div>
    </div>

<script>
(function() {
    'use strict';
    // --- 1. DOM & Canvas Setup ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const menuScreen = document.getElementById('menu-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const hudTeamInfo = document.getElementById('team-info');
    const hudPlayersLeft = document.getElementById('players-left');
    const hudZoneTimer = document.getElementById('zone-timer');
    const hudAmmoInfo = document.getElementById('hud-ammo-info');
    const hudAmmoCount = document.getElementById('ammo-count');
    const minimapCanvas = document.getElementById('minimap-canvas');
    const minimapCtx = minimapCanvas.getContext('2d');
    
    // NEW: Menu buttons and multiplayer UI
    const createGameBtn = document.getElementById('create-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const playSoloBtn = document.getElementById('play-solo-btn');
    const playAgainButton = document.getElementById('play-again-button');
    const joinIdInput = document.getElementById('join-id-input');
    const peerIdDisplay = document.getElementById('my-peer-id-display');

    // --- 2. Game Constants ---
    const MAP_WIDTH = 3000;
    const MAP_HEIGHT = 3000;
    const PLAYER_SIZE = 30;
    const PLAYER_SPEED = 4;
    const PLAYER_HP = 100;
    const PLAYER_SHIELD = 50;
    const WILD_GLYPH_COUNT = 15;
    const HEALTH_PICKUP_COUNT = 10;
    const ZONE_SHRINK_INTERVAL = 30000; // 30 seconds
    const ZONE_INITIAL_RADIUS = 1400;
    const ZONE_DAMAGE = 0.15;
    const CAMERA_SMOOTHING = 0.08;

    const MAP_THEMES = ['cyber', 'inferno', 'toxic', 'ocean', 'candy', 'jungle', 'mono', 'desert', 'royal', 'ghostly'];
    const PLAYER_EMOJIS = ['ðŸ˜€', 'ðŸ˜Ž', 'ðŸ˜‚', 'ðŸ¥³', 'ðŸ˜­', 'ðŸ˜¡', 'ðŸ¤¯', 'ðŸ˜±'];
    const MONSTER_EMOJIS = ['ðŸ‘¾', 'ðŸ‘¹', 'ðŸ‘º', 'ðŸ‘½', 'ðŸ¤–'];
    
    const WEAPON_TYPES = {
        'ðŸ˜€': { name: 'Standard', fireRate: 20, bulletSpeed: 8, damage: 10, bulletEmoji: 'âšª', clipSize: 30, reloadTime: 120 },
        'ðŸ˜Ž': { name: 'Rifle', fireRate: 15, bulletSpeed: 12, damage: 12, bulletEmoji: 'ðŸ”¹', clipSize: 20, reloadTime: 140 },
        'ðŸ˜‚': { name: 'Shotgun', fireRate: 40, bulletSpeed: 7, damage: 8, bulletEmoji: 'ðŸ’¥', bulletCount: 5, spread: 0.4, clipSize: 8, reloadTime: 160 },
        'ðŸ¥³': { name: 'Confetti Gun', fireRate: 10, bulletSpeed: 6, damage: 5, bulletEmoji: 'ðŸŽ‰', bulletCount: 3, spread: 0.6, clipSize: 50, reloadTime: 180 },
        'ðŸ˜­': { name: 'Tear Stream', fireRate: 5, bulletSpeed: 9, damage: 4, bulletEmoji: 'ðŸ’§', clipSize: 100, reloadTime: 200 },
        'ðŸ˜¡': { name: 'Minigun', fireRate: 4, bulletSpeed: 10, damage: 6, bulletEmoji: 'ðŸ”¸', clipSize: 80, reloadTime: 240 },
        'ðŸ¤¯': { name: 'Rocket', fireRate: 60, bulletSpeed: 5, damage: 35, bulletEmoji: 'ðŸš€', clipSize: 5, reloadTime: 180 },
        'ðŸ˜±': { name: 'Ghost Shot', fireRate: 25, bulletSpeed: 6, damage: 15, bulletEmoji: 'ðŸ‘»', clipSize: 15, reloadTime: 130 },
        'default': { name: 'Default', fireRate: 20, bulletSpeed: 8, damage: 10, bulletEmoji: 'âšª', clipSize: 30, reloadTime: 120 },
    };

    // --- 3. Game State ---
    let gameState = 'menu'; // 'menu', 'playing', 'gameover'
    let game;
    let animationFrameId;

    // --- 4. Utility Functions ---
    const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const getRandomElement = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const lerp = (a, b, t) => a + (b - a) * t;
    
    // --- 5. Game Classes (Mostly Unchanged) ---
    // Note: Most classes are identical to the original. The key changes are in the Game class.
    class Character {
        constructor(x, y, size, emoji, team, hp = 100, id = null) { // NEW: ID parameter
            this.id = id || Math.random(); // Use provided ID or generate one
            this.x = x; this.y = y;
            this.size = size;
            this.emoji = emoji;
            this.team = team;
            this.hp = hp; this.maxHp = hp;
            this.shield = 0; this.maxShield = 0;
            this.shieldRechargeTimer = 0;
            this.isAlive = true;
            this.vx = 0; this.vy = 0;
            this.angle = 0;
        }
        draw(ctx) { /* ... (code unchanged) ... */
             if (this.isAlive && this.shield > 0) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.2, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 196, 255, ${0.3 + (this.shield / this.maxShield) * 0.7})`;
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            const barWidth = this.size * 1.5;
            const barHeight = 8;
            ctx.fillStyle = '#333';
            ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 15, barWidth, barHeight);
            
            const healthPercent = this.hp / this.maxHp;
            ctx.fillStyle = healthPercent > 0.5 ? 'var(--health-green)' : healthPercent > 0.25 ? 'var(--health-yellow)' : 'var(--health-red)';
            ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 15, barWidth * healthPercent, barHeight);

            ctx.font = `${this.size * 2}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x, this.y);
        }
        takeDamage(amount, instigator) {
             if (!this.isAlive) return;
            this.shieldRechargeTimer = 180;
            let damageLeft = amount;
            if (this.shield > 0) {
                const shieldDamage = Math.min(this.shield, damageLeft);
                this.shield -= shieldDamage;
                damageLeft -= shieldDamage;
            }
            if (damageLeft > 0) this.hp -= damageLeft;
            if (this.hp <= 0) {
                this.hp = 0;
                this.isAlive = false;
                game.onCharacterDeath(this);
            }
            if(this.isHuman) game.triggerScreenShake(5);
        }
        isOpponent(otherCharacter) { return this.isAlive && otherCharacter.isAlive && this.team !== otherCharacter.team; }
        updateShield() {
            if (this.shieldRechargeTimer > 0) this.shieldRechargeTimer--;
            else if (this.shield < this.maxShield) this.shield = Math.min(this.maxShield, this.shield + 0.2);
        }
    }

    class Player extends Character {
        constructor(x, y, emoji, team, isHuman = false, id = null) {
            super(x, y, PLAYER_SIZE, emoji, team, PLAYER_HP, id);
            this.isHuman = isHuman;
            this.weapon = WEAPON_TYPES[emoji] || WEAPON_TYPES['default'];
            this.ammo = this.weapon.clipSize;
            this.isReloading = false;
            this.reloadTimer = 0;
            this.shootCooldown = 0;
            this.shield = this.maxShield = isHuman ? PLAYER_SHIELD * 1.5 : PLAYER_SHIELD;
            this.aiTarget = null;
            this.aiMoveTimer = 0;
        }
        update(input, mouse, allCharacters, game) { /* ... (code unchanged, but logic will be conditionally run by host) ... */ 
            if (!this.isAlive) return;
            this.updateShield();
            this.updateReload();

            if (this.isHuman) this.handleHumanInput(input, mouse.worldX, mouse.worldY);
            else this.handleAIInput(allCharacters, game.zone);

            this.x += this.vx; this.y += this.vy;
            this.x = Math.max(this.size, Math.min(MAP_WIDTH - this.size, this.x));
            this.y = Math.max(this.size, Math.min(MAP_HEIGHT - this.size, this.y));

            if (this.shootCooldown > 0) this.shootCooldown--;
            
            const shouldShoot = (this.isHuman && (input.shooting || input.controllerShooting || input.touchShooting)) || (!this.isHuman && this.aiTarget);
            if (shouldShoot) this.shoot(game);
        }
        handleHumanInput(input, mouseX, mouseY) { /* ... (code unchanged) ... */
            let finalMoveX = 0, finalMoveY = 0;
            if (input.touchMoveV.x !== 0 || input.touchMoveV.y !== 0) {
                finalMoveX = input.touchMoveV.x;
                finalMoveY = input.touchMoveV.y;
            } else if (Math.abs(input.controllerMoveX) > 0 || Math.abs(input.controllerMoveY) > 0) {
                finalMoveX = input.controllerMoveX;
                finalMoveY = input.controllerMoveY;
            } else {
                if (input.keys.w || input.keys.arrowup) finalMoveY -= 1;
                if (input.keys.s || input.keys.arrowdown) finalMoveY += 1;
                if (input.keys.a || input.keys.arrowleft) finalMoveX -= 1;
                if (input.keys.d || input.keys.arrowright) finalMoveX += 1;
            }
            const moveMagnitude = Math.sqrt(finalMoveX * finalMoveX + finalMoveY * finalMoveY);
            if (moveMagnitude > 1) { finalMoveX /= moveMagnitude; finalMoveY /= moveMagnitude; }
            this.vx = finalMoveX * PLAYER_SPEED;
            this.vy = finalMoveY * PLAYER_SPEED;

            if (input.touchAimV.x !== 0 || input.touchAimV.y !== 0) {
                this.angle = Math.atan2(input.touchAimV.y, input.touchAimV.x);
            } else if (Math.abs(input.controllerAimX) > 0 || Math.abs(input.controllerAimY) > 0) {
                this.angle = Math.atan2(input.controllerAimY, input.controllerAimX);
            } else {
                this.angle = Math.atan2(mouseY - this.y, mouseX - this.x);
            }
            if (input.keys.r) this.startReload();
        }
        handleAIInput(allCharacters, zone) { /* ... (code unchanged) ... */ 
            const distToZoneCenter = distance(this.x, this.y, zone.x, zone.y);
            if (distToZoneCenter > zone.radius - 50) { 
                const angleToCenter = Math.atan2(zone.y - this.y, zone.x - this.x);
                this.vx = Math.cos(angleToCenter) * PLAYER_SPEED * 0.7;
                this.vy = Math.sin(angleToCenter) * PLAYER_SPEED * 0.7;
                this.aiTarget = null;
                return;
            }
            this.aiMoveTimer--;
            if (this.aiMoveTimer <= 0) {
                 this.vx = getRandomInt(-1, 1) * PLAYER_SPEED * 0.5;
                 this.vy = getRandomInt(-1, 1) * PLAYER_SPEED * 0.5;
                 this.aiMoveTimer = getRandomInt(60, 180);
            }
            let sightRange = 500;
            let closestOpponent = null;
            let minDistance = sightRange; 
            for (const char of allCharacters) {
                if (this.isOpponent(char)) {
                    const d = distance(this.x, this.y, char.x, char.y);
                    if (d < minDistance) {
                        minDistance = d;
                        closestOpponent = char;
                    }
                }
            }
            if (closestOpponent) {
                this.aiTarget = closestOpponent;
                const targetAngle = Math.atan2(closestOpponent.y - this.y, closestOpponent.x - this.x);
                this.angle = targetAngle + (Math.random() - 0.5) * 0.2;
            } else {
                this.aiTarget = null;
            }
        }
        shoot(game) { /* ... (code unchanged) ... */
             if (this.shootCooldown <= 0 && !this.isReloading && this.ammo > 0) {
                const w = this.weapon;
                const bulletCount = w.bulletCount || 1;
                for (let i = 0; i < bulletCount; i++) {
                    const spreadAngle = w.spread ? (Math.random() - 0.5) * w.spread : 0;
                    const bullet = new Bullet(this.x, this.y, this.angle + spreadAngle, this.team, this);
                    game.bullets.push(bullet);
                }
                this.shootCooldown = w.fireRate;
                this.ammo--;
                if (this.ammo <= 0) this.startReload();
            }
        }
        startReload() { /* ... (code unchanged) ... */
             if (this.isReloading || this.ammo === this.weapon.clipSize) return;
            this.isReloading = true;
            this.reloadTimer = this.weapon.reloadTime;
        }
        updateReload() { /* ... (code unchanged) ... */
             if (this.isReloading) {
                this.reloadTimer--;
                if (this.reloadTimer <= 0) {
                    this.isReloading = false;
                    this.ammo = this.weapon.clipSize;
                }
            }
        }
    }
    class Pickup { /* ... (code unchanged) ... */ 
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.size = 20;
            this.emoji = type === 'health' ? 'âž•' : 'â“';
            this.isAlive = true;
        }
        draw(ctx) {
            ctx.font = `${this.size * 2}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x, this.y);
        }
    }
    class Bullet { /* ... (code unchanged) ... */
        constructor(x, y, angle, team, owner) {
            this.x = x; this.y = y; this.angle = angle;
            this.team = team; this.owner = owner;
            const w = owner.weapon;
            this.size = 10;
            this.vx = Math.cos(angle) * w.bulletSpeed;
            this.vy = Math.sin(angle) * w.bulletSpeed;
            this.damage = w.damage;
            this.emoji = w.bulletEmoji;
            this.life = 150;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life--; }
        draw(ctx) {
            ctx.font = `${this.size * 2}px sans-serif`;
            ctx.fillText(this.emoji, this.x, this.y);
        }
    }
    class Particle { /* ... (code unchanged) ... */
        constructor(x, y, color, size, life) {
            this.x = x; this.y = y;
            this.color = color;
            this.size = getRandomInt(size[0], size[1]);
            this.vx = Math.random() * 4 - 2; this.vy = Math.random() * 4 - 2;
            this.life = this.maxLife = getRandomInt(life[0], life[1]);
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vx *= 0.98; this.vy *= 0.98;
            this.life--;
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Game {
        constructor(mode = 'solo', remoteId = null) {
            // NEW: Multiplayer state
            this.mode = mode; // 'solo', 'host', 'client'
            this.peer = null;
            this.conn = null;
            this.myPlayerId = null;
            this.isHost = (mode === 'host' || mode === 'solo');

            this.players = []; this.wildGlyphs = []; this.pickups = [];
            this.bullets = []; this.particles = [];
            this.playerMap = new Map(); // NEW: Efficiently find players by ID

            this.zone = {}; this.camera = { x: 0, y: 0 };
            
            this.input = { keys: {}, shooting: false, gamepad: null, prevGamepadButtons: [], controllerMoveX: 0, controllerMoveY: 0, controllerAimX: 0, controllerAimY: 0, controllerShooting: false, touchMoveId: null, touchAimId: null, touchMoveStart: { x: 0, y: 0 }, touchAimStart: { x: 0, y: 0 }, touchMoveV: { x: 0, y: 0 }, touchAimV: { x: 0, y: 0 }, touchShooting: false };
            this.mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
            this.hudTeamElements = [];
            this.screenShakeMagnitude = 0;
            
            this.setupTouchControls();
            this.setupInputListeners();
            
            if (mode === 'solo') {
                this.start();
            } else {
                this.initPeer(remoteId);
            }
        }

        // --- NEW: PeerJS NETWORKING LOGIC ---
        initPeer(remoteId) {
            this.peer = new Peer();

            this.peer.on('open', id => {
                console.log('My peer ID is: ' + id);
                peerIdDisplay.innerHTML = `Your ID: <span onclick="navigator.clipboard.writeText('${id}')">${id}</span> (Click to copy)`;
                if (this.mode === 'client') {
                    this.connectToHost(remoteId);
                } else { // host
                    peerIdDisplay.innerHTML += '<br>Waiting for friend to join...';
                }
            });

            this.peer.on('connection', conn => {
                console.log('Friend connected!');
                this.conn = conn;
                this.setupConnectionEvents();
                if (this.isHost) {
                   this.start(); // A player has connected, start the game as host
                }
            });
            
            this.peer.on('error', err => console.error(err));
        }

        connectToHost(remoteId) {
            console.log('Attempting to connect to host: ' + remoteId);
            this.conn = this.peer.connect(remoteId);
            if (!this.conn) {
                alert("Connection failed. Are you sure the ID is correct?");
                return;
            }
            this.setupConnectionEvents();
        }

        setupConnectionEvents() {
            this.conn.on('data', data => {
                // This is where all messages from the other player are handled
                if (data.type === 'initial-state') {
                    // Client receives the initial world from the host
                    this.applyInitialState(data.payload);
                    this.start(); // Start the game on the client side
                } else if (data.type === 'state-update') {
                    // Client receives a regular update from the host
                    this.applyState(data.payload);
                } else if (data.type === 'input-update') {
                    // Host receives input from the client
                    this.applyRemoteInput(data.payload);
                }
            });
            
            this.conn.on('open', () => {
                console.log('Connection established!');
                peerIdDisplay.innerHTML = 'Connected to friend!';
            });
        }
        
        applyRemoteInput(inputData) {
            if (!this.isHost) return;
            const remotePlayer = this.playerMap.get(this.remotePlayerId);
            if (remotePlayer) {
                remotePlayer.vx = inputData.vx;
                remotePlayer.vy = inputData.vy;
                remotePlayer.angle = inputData.angle;
                
                if (inputData.shooting) remotePlayer.shoot(this);
                if (inputData.reloading) remotePlayer.startReload();
            }
        }

        // --- GAME LIFECYCLE (MODIFIED) ---

        init() {
            // Only the host or solo player generates the world
            if (!this.isHost) return; 

            this.players = []; this.wildGlyphs = []; this.bullets = []; this.particles = []; this.pickups = [];
            this.playerMap.clear();

            this.zone = { x: MAP_WIDTH / 2, y: MAP_HEIGHT / 2, radius: ZONE_INITIAL_RADIUS, shrinkTimer: ZONE_SHRINK_INTERVAL };

            const randomTheme = getRandomElement(MAP_THEMES);
            document.body.className = `theme-${randomTheme}`;

            const blueSpawnQuadrant = getRandomInt(1, 4);
            const redSpawnQuadrant = (blueSpawnQuadrant + 1) % 4 + 1;
            const getSpawnPoint = (q) => { /* ... (code unchanged) ... */ 
                const qWidth = MAP_WIDTH / 2; const qHeight = MAP_HEIGHT / 2;
                const padding = 200;
                switch (q) {
                    case 1: return { x: getRandomInt(padding, qWidth - padding), y: getRandomInt(padding, qHeight - padding) };
                    case 2: return { x: getRandomInt(qWidth + padding, MAP_WIDTH - padding), y: getRandomInt(padding, qHeight - padding) };
                    case 3: return { x: getRandomInt(padding, qWidth - padding), y: getRandomInt(qHeight + padding, MAP_HEIGHT - padding) };
                    case 4: return { x: getRandomInt(qWidth + padding, MAP_WIDTH - padding), y: getRandomInt(qHeight + padding, MAP_HEIGHT - padding) };
                }
            };
            const usedEmojis = new Set();
            const getUniqueEmoji = () => { /* ... (code unchanged) ... */ 
                let emoji;
                do { emoji = getRandomElement(PLAYER_EMOJIS); } while (usedEmojis.has(emoji));
                usedEmojis.add(emoji);
                return emoji;
            };

            const blueCenter = getSpawnPoint(blueSpawnQuadrant);
            // First player (always host in multiplayer)
            const p1 = new Player(blueCenter.x, blueCenter.y, getUniqueEmoji(), 'blue', true);
            this.myPlayerId = p1.id;
            this.players.push(p1);

            // Add second human player for multiplayer games
            if (this.mode === 'host') {
                 const p2 = new Player(blueCenter.x + 50, blueCenter.y + 50, getUniqueEmoji(), 'blue', true);
                 this.remotePlayerId = p2.id;
                 this.players.push(p2);
                 // Add 2 bots
                 for (let i = 0; i < 2; i++) this.players.push(new Player(blueCenter.x + getRandomInt(-100, 100), blueCenter.y + getRandomInt(-100, 100), getUniqueEmoji(), 'blue'));
            } else { // solo
                 // Add 3 bots
                 for (let i = 0; i < 3; i++) this.players.push(new Player(blueCenter.x + getRandomInt(-100, 100), blueCenter.y + getRandomInt(-100, 100), getUniqueEmoji(), 'blue'));
            }
            
            const redCenter = getSpawnPoint(redSpawnQuadrant);
            for (let i = 0; i < 4; i++) this.players.push(new Player(redCenter.x + getRandomInt(-100, 100), redCenter.y + getRandomInt(-100, 100), getUniqueEmoji(), 'red'));

            for (let i = 0; i < WILD_GLYPH_COUNT; i++) this.wildGlyphs.push(new Player(getRandomInt(0, MAP_WIDTH), getRandomInt(0, MAP_HEIGHT), getRandomElement(MONSTER_EMOJIS), 'monster', false));
            for (let i = 0; i < HEALTH_PICKUP_COUNT; i++) this.pickups.push(new Pickup(getRandomInt(100, MAP_WIDTH-100), getRandomInt(100, MAP_HEIGHT-100), 'health'));

            this.players.forEach(p => this.playerMap.set(p.id, p));

            // If we are a host, send the initial state to the client
            if (this.mode === 'host' && this.conn) {
                const initialState = this.serializeInitialState();
                this.conn.send({ type: 'initial-state', payload: initialState });
            }
        }
        
        start() {
            if (this.isHost) this.init(); // Host/Solo generates the world
            
            gameState = 'playing';
            menuScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (this.mode !== 'solo') {
                this.initHUD(); // Init HUD after receiving state for clients
            } else {
                this.initHUD(); // Init HUD immediately for solo
            }

            this.loop();
        }

        loop() {
            this.update(); this.draw();
            if (gameState === 'playing') animationFrameId = requestAnimationFrame(this.loop.bind(this));
        }

        update() {
            this.pollGamepad();
            
            if (this.isHost) {
                // --- HOST/SOLO LOGIC: RUN THE FULL SIMULATION ---
                const allCharacters = [...this.players, ...this.wildGlyphs];
                
                // For host, update only non-remote players based on local input/AI
                const myPlayer = this.playerMap.get(this.myPlayerId);
                if (myPlayer) myPlayer.update(this.input, this.mouse, allCharacters, this);
                
                allCharacters.forEach(p => {
                    if (p.id !== this.myPlayerId && p.id !== this.remotePlayerId) {
                         p.update(this.input, this.mouse, allCharacters, this);
                    } else if (p.id === this.remotePlayerId) {
                        // Remote player movement/angle is applied via network message
                        // But we still need to run internal updates
                        p.updateShield();
                        p.updateReload();
                        p.x += p.vx; p.y += p.vy;
                        p.x = Math.max(p.size, Math.min(MAP_WIDTH - p.size, p.x));
                        p.y = Math.max(p.size, Math.min(MAP_HEIGHT - p.size, p.y));
                        if (p.shootCooldown > 0) p.shootCooldown--;
                    }
                });

                this.bullets.forEach(b => b.update());
                this.particles.forEach(p => p.update());
                
                this.bullets = this.bullets.filter(b => b.life > 0 && b.x > 0 && b.x < MAP_WIDTH && b.y > 0 && b.y < MAP_HEIGHT);
                this.particles = this.particles.filter(p => p.life > 0);
                this.pickups = this.pickups.filter(p => p.isAlive);

                this.checkCollisions();
                this.updateZone();
                this.checkGameOver();
                
                // Send state to client
                if (this.mode === 'host' && this.conn) {
                    this.conn.send({ type: 'state-update', payload: this.serializeState() });
                }
            } else {
                // --- CLIENT LOGIC: SEND INPUT TO HOST ---
                const myPlayer = this.playerMap.get(this.myPlayerId);
                if (myPlayer) {
                    // We only calculate our intended movement and send it. The host does the rest.
                    let inputPayload = { vx: 0, vy: 0, angle: myPlayer.angle, shooting: false, reloading: false };
                    myPlayer.handleHumanInput(this.input, this.mouse.worldX, this.mouse.worldY); // this updates player's vx/vy/angle
                    inputPayload.vx = myPlayer.vx;
                    inputPayload.vy = myPlayer.vy;
                    inputPayload.angle = myPlayer.angle;
                    inputPayload.shooting = this.input.shooting || this.input.controllerShooting || this.input.touchShooting;
                    if(this.input.keys.r) inputPayload.reloading = true; // Simplified reload signal

                    this.conn.send({ type: 'input-update', payload: inputPayload });
                }
            }
            
            const human = this.playerMap.get(this.myPlayerId);
            if (human) {
                const targetX = human.x - canvas.width / 2;
                const targetY = human.y - canvas.height / 2;
                this.camera.x = lerp(this.camera.x, targetX, CAMERA_SMOOTHING);
                this.camera.y = lerp(this.camera.y, targetY, CAMERA_SMOOTHING);
            }
            this.mouse.worldX = this.mouse.x + this.camera.x;
            this.mouse.worldY = this.mouse.y + this.camera.y;
            this.updateScreenShake();
            this.updateHUD(); 
        }

        draw() { /* ... (code unchanged) ... */
             canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            ctx.save();
            ctx.translate(-this.camera.x, -this.camera.y);
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
            ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--zone-color');
            ctx.beginPath();
            ctx.arc(this.zone.x, this.zone.y, this.zone.radius, 0, Math.PI * 2);
            ctx.rect(MAP_WIDTH, 0, -MAP_WIDTH, MAP_HEIGHT);
            ctx.fill("evenodd");
            this.pickups.forEach(p => p.draw(ctx));
            [...this.players, ...this.wildGlyphs].forEach(char => { if (char.isAlive) char.draw(ctx); });
            this.bullets.forEach(b => b.draw(ctx));
            this.particles.forEach(p => p.draw(ctx));
            ctx.restore();
            this.drawMinimap();
        }
        
        // --- DATA SERIALIZATION AND STATE APPLICATION (NEW) ---

        serializeInitialState() {
            // Send more data the first time
            return {
                myPlayerId: this.remotePlayerId, // The client's ID is the host's remotePlayerId
                remotePlayerId: this.myPlayerId, // The host's ID is the client's remotePlayerId
                mapTheme: document.body.className,
                players: this.players.map(p => ({
                    id: p.id, x: p.x, y: p.y, emoji: p.emoji, team: p.team, isHuman: p.isHuman
                })),
                wildGlyphs: this.wildGlyphs.map(g => ({
                    id: g.id, x: g.x, y: g.y, emoji: g.emoji, team: g.team
                }))
            };
        }
        
        applyInitialState(state) {
            // Client builds the world based on host's data
            this.myPlayerId = state.myPlayerId;
            this.remotePlayerId = state.remotePlayerId;
            document.body.className = state.mapTheme;
            
            this.players = state.players.map(pData => {
                const p = new Player(pData.x, pData.y, pData.emoji, pData.team, pData.id === this.myPlayerId, pData.id);
                this.playerMap.set(p.id, p);
                return p;
            });
            this.wildGlyphs = state.wildGlyphs.map(gData => {
                 const g = new Player(gData.x, gData.y, gData.emoji, gData.team, false, gData.id);
                 this.playerMap.set(g.id, g);
                 return g;
            });
        }
        
        serializeState() {
            // Send only the data that changes frequently
            return {
                players: this.players.map(p => ({
                    id: p.id, x: p.x, y: p.y, hp: p.hp, shield: p.shield, angle: p.angle, isAlive: p.isAlive, ammo: p.ammo, isReloading: p.isReloading
                })),
                bullets: this.bullets.map(b => ({ x: b.x, y: b.y, emoji: b.emoji })),
                zone: { x: this.zone.x, y: this.zone.y, radius: this.zone.radius, shrinkTimer: this.zone.shrinkTimer }
            };
        }
        
        applyState(state) {
            // Client updates its local objects with data from the host
            state.players.forEach(pData => {
                const p = this.playerMap.get(pData.id);
                if (p) {
                    // Smoothly interpolate positions for other players
                    if (p.id !== this.myPlayerId) {
                        p.x = lerp(p.x, pData.x, 0.3);
                        p.y = lerp(p.y, pData.y, 0.3);
                    } else {
                        // Instantly update our own player's authoritative position
                        p.x = pData.x;
                        p.y = pData.y;
                    }
                    p.hp = pData.hp;
                    p.shield = pData.shield;
                    p.angle = pData.angle;
                    p.isAlive = pData.isAlive;
                    p.ammo = pData.ammo;
                    p.isReloading = pData.isReloading;
                }
            });
            
            // For bullets, just replace the array entirely as they are transient
            this.bullets = state.bullets.map(bData => ({
                x: bData.x, y: bData.y, emoji: bData.emoji,
                draw: (ctx) => { ctx.font = `20px sans-serif`; ctx.fillText(bData.emoji, bData.x, bData.y); }
            }));
            
            this.zone = state.zone;
        }

        // --- UNCHANGED HELPER METHODS ---
        checkCollisions() { /* ... (code unchanged) ... */
             const allCharacters = [...this.players, ...this.wildGlyphs];
            for (const bullet of this.bullets) {
                for (const char of allCharacters) {
                    if (char.isAlive && char.team !== bullet.team) {
                        if (distance(bullet.x, bullet.y, char.x, char.y) < char.size) {
                            char.takeDamage(bullet.damage, bullet.owner);
                            bullet.life = 0;
                            this.createParticles(char.x, char.y, 5, 'orange', [2,4], [20,40]);
                            break;
                        }
                    }
                }
            }
            for (const player of allCharacters) {
                if (!player.isAlive) continue;
                for (const pickup of this.pickups) {
                    if (distance(player.x, player.y, pickup.x, pickup.y) < player.size + pickup.size) {
                        if (pickup.type === 'health' && player.hp < player.maxHp) {
                           player.hp = Math.min(player.maxHp, player.hp + 50);
                           pickup.isAlive = false;
                           this.createParticles(pickup.x, pickup.y, 15, 'var(--health-green)', [2,5], [30, 60]);
                        }
                    }
                }
            }
        }
        updateZone() { /* ... (code unchanged) ... */ 
            this.zone.shrinkTimer -= 16.67;
            if (this.zone.shrinkTimer <= 0) {
                this.zone.radius = Math.max(100, this.zone.radius * 0.75);
                this.zone.shrinkTimer = ZONE_SHRINK_INTERVAL;
            }
            [...this.players, ...this.wildGlyphs].forEach(char => {
                if (distance(char.x, char.y, this.zone.x, this.zone.y) > this.zone.radius) {
                    char.takeDamage(ZONE_DAMAGE);
                }
            });
        }
        updateScreenShake() { /* ... (code unchanged) ... */
             if(this.screenShakeMagnitude > 0) {
                const sx = (Math.random() - 0.5) * this.screenShakeMagnitude;
                const sy = (Math.random() - 0.5) * this.screenShakeMagnitude;
                gameContainer.style.transform = `translate(${sx}px, ${sy}px)`;
                this.screenShakeMagnitude *= 0.9;
            } else {
                 gameContainer.style.transform = `translate(0, 0)`;
            }
        }
        drawMinimap() { /* ... (code unchanged) ... */
             const mmSize = 200;
            minimapCanvas.width = mmSize;
            minimapCanvas.height = mmSize;
            const scale = mmSize / MAP_WIDTH;

            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapCtx.fillRect(0, 0, mmSize, mmSize);

            minimapCtx.fillStyle = 'rgba(100, 100, 255, 0.2)';
            minimapCtx.strokeStyle = 'rgba(150, 150, 255, 0.5)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(this.zone.x * scale, this.zone.y * scale, this.zone.radius * scale, 0, Math.PI * 2);
            minimapCtx.fill();
            minimapCtx.stroke();

            this.players.forEach(p => {
                if (!p.isAlive) return;
                minimapCtx.fillStyle = p.id === this.myPlayerId ? 'white' : (p.team === 'blue' ? 'var(--blue-team-color)' : 'var(--red-team-color)');
                minimapCtx.fillRect(p.x * scale - 2, p.y * scale - 2, 4, 4);
            });
        }
        initHUD() { /* ... (code modified to use myPlayerId) ... */
            hudTeamInfo.innerHTML = '<h3>Your Team</h3>';
            this.hudTeamElements = [];
            const myPlayer = this.playerMap.get(this.myPlayerId);
            if (!myPlayer) return;

            const humanPlayerTeam = this.players.filter(p => p.team === myPlayer.team);
            humanPlayerTeam.forEach(p => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'team-member';
                if (p.id === this.myPlayerId) playerDiv.classList.add('player-is-you');
                
                playerDiv.innerHTML = `
                    <span>${p.emoji}</span>
                    <div class="health-shield-container">
                        <div class="bar"><div class="bar-inner health-bar"></div></div>
                        <div class="bar"><div class="bar-inner shield-bar"></div></div>
                    </div>`;
                
                this.hudTeamElements.push({ 
                    player: p, div: playerDiv, 
                    healthBar: playerDiv.querySelector('.health-bar'), 
                    shieldBar: playerDiv.querySelector('.shield-bar') 
                });
                hudTeamInfo.appendChild(playerDiv);
            });
        }
        updateHUD() { /* ... (code modified to find human player) ... */
            this.hudTeamElements.forEach(elem => {
                const p = elem.player;
                elem.div.classList.toggle('eliminated', !p.isAlive);
                const healthPercent = (p.hp / p.maxHp) * 100;
                elem.healthBar.style.width = `${healthPercent}%`;
                elem.healthBar.style.backgroundColor = `var(--health-${healthPercent > 50 ? 'green' : healthPercent > 25 ? 'yellow' : 'red'})`;
                const shieldPercent = (p.shield / p.maxShield) * 100;
                elem.shieldBar.style.width = `${shieldPercent}%`;
            });
            const alivePlayers = this.players.filter(p => p.isAlive).length;
            hudPlayersLeft.textContent = alivePlayers;
            hudZoneTimer.textContent = Math.max(0, Math.ceil(this.zone.shrinkTimer / 1000));
            const human = this.playerMap.get(this.myPlayerId);
            if (human) {
                const ammoInfoDiv = document.getElementById('ammo-info'); // Re-selecting for safety
                if(human.isReloading) {
                    ammoInfoDiv.classList.add('reloading');
                    hudAmmoCount.textContent = "RELOADING";
                } else {
                    ammoInfoDiv.classList.remove('reloading');
                    hudAmmoCount.textContent = `${human.ammo} / ${human.weapon.clipSize}`;
                }
            }
        }
        checkGameOver() { /* ... (code modified to use myPlayerId) ... */
            if (gameState !== 'playing') return;
            const aliveTeams = new Set(this.players.filter(p => p.isAlive).map(p => p.team));

            if (aliveTeams.size <= 1) {
                gameState = 'gameover';
                const human = this.playerMap.get(this.myPlayerId);
                if (human && human.isAlive) {
                    document.getElementById('game-over-title').innerText = 'VICTORY ROYALE!';
                    document.getElementById('game-over-message').innerText = 'Your team was the last one smiling.';
                } else {
                    document.getElementById('game-over-title').innerText = 'GAME OVER';
                    document.getElementById('game-over-message').innerText = 'Better luck next time!';
                }
                gameOverScreen.classList.remove('hidden');
            }
        }
        createParticles(x, y, count, color, sizeRange, lifeRange) { /* ... (code unchanged) ... */ 
            for (let i = 0; i < count; i++) this.particles.push(new Particle(x, y, color, sizeRange, lifeRange));
        }
        onCharacterDeath(character) { /* ... (code unchanged) ... */
             const deathColor = character.team === 'blue' ? 'var(--blue-team-color)' : character.team === 'red' ? 'var(--red-team-color)' : 'var(--monster-color)';
             this.createParticles(character.x, character.y, 40, deathColor, [2, 6], [40, 80]);
        }
        triggerScreenShake(magnitude) { this.screenShakeMagnitude = Math.max(this.screenShakeMagnitude, magnitude); }
        pollGamepad() { /* ... (code unchanged) ... */ 
            const gamepads = navigator.getGamepads();
            if (gamepads.length > 0 && gamepads[0]) this.input.gamepad = gamepads[0];
            else this.input.gamepad = null;
            if (!this.input.gamepad) {
                this.input.controllerMoveX = 0; this.input.controllerMoveY = 0; this.input.controllerAimX = 0; this.input.controllerAimY = 0; this.input.controllerShooting = false;
                return;
            }
            const gamepad = this.input.gamepad, deadzone = 0.2;
            let moveX = gamepad.axes[0]; let moveY = gamepad.axes[1];
            this.input.controllerMoveX = Math.abs(moveX) > deadzone ? moveX : 0;
            this.input.controllerMoveY = Math.abs(moveY) > deadzone ? moveY : 0;
            let aimX = gamepad.axes[2]; let aimY = gamepad.axes[3];
            this.input.controllerAimX = Math.abs(aimX) > deadzone ? aimX : 0;
            this.input.controllerAimY = Math.abs(aimY) > deadzone ? aimY : 0;
            this.input.controllerShooting = gamepad.buttons[7].value > 0.1;
            const reloadPressed = gamepad.buttons[2].pressed, prevReloadPressed = this.input.prevGamepadButtons[2] || false;
            if (reloadPressed && !prevReloadPressed) {
                const human = this.playerMap.get(this.myPlayerId);
                if (human) human.startReload();
            }
            this.input.prevGamepadButtons = gamepad.buttons.map(b => b.pressed);
        }
        setupTouchControls() { /* ... (code unchanged) ... */
             if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.body.classList.add('touch-enabled');
                this.touchMoveStick = document.getElementById('joystick-move');
                this.touchMoveNub = this.touchMoveStick.querySelector('.joystick-nub');
                this.touchAimStick = document.getElementById('joystick-aim');
                this.touchAimNub = this.touchAimStick.querySelector('.joystick-nub');
                this.touchReloadBtn = document.getElementById('reload-button');
            }
        }
        handleTouchStart(e) { /* ... (code unchanged) ... */
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                if (this.touchReloadBtn.contains(e.target)) continue;
                if (touch.clientX < window.innerWidth / 2 && this.input.touchMoveId === null) {
                    this.input.touchMoveId = touch.identifier;
                    this.input.touchMoveStart.x = touch.clientX; this.input.touchMoveStart.y = touch.clientY;
                    this.touchMoveStick.style.left = `${touch.clientX - 60}px`; this.touchMoveStick.style.top = `${touch.clientY - 60}px`; this.touchMoveStick.style.display = 'block';
                } else if (touch.clientX >= window.innerWidth / 2 && this.input.touchAimId === null) {
                    this.input.touchAimId = touch.identifier;
                    this.input.touchAimStart.x = touch.clientX; this.input.touchAimStart.y = touch.clientY;
                    this.touchAimStick.style.left = `${touch.clientX - 60}px`; this.touchAimStick.style.top = `${touch.clientY - 60}px`; this.touchAimStick.style.display = 'block';
                }
            }
        }
        handleTouchMove(e) { /* ... (code unchanged) ... */ 
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i]; const stickLimit = 50; 
                if (touch.identifier === this.input.touchMoveId) {
                    let dx = touch.clientX - this.input.touchMoveStart.x, dy = touch.clientY - this.input.touchMoveStart.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 10) { this.input.touchMoveV.x = dx / dist; this.input.touchMoveV.y = dy / dist; } else { this.input.touchMoveV.x = 0; this.input.touchMoveV.y = 0; }
                    this.touchMoveNub.style.transform = `translate(${Math.min(stickLimit, Math.max(-stickLimit, dx))}px, ${Math.min(stickLimit, Math.max(-stickLimit, dy))}px)`;
                } else if (touch.identifier === this.input.touchAimId) {
                    let dx = touch.clientX - this.input.touchAimStart.x, dy = touch.clientY - this.input.touchAimStart.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 15) { this.input.touchAimV.x = dx / dist; this.input.touchAimV.y = dy / dist; this.input.touchShooting = true; } else { this.input.touchAimV.x = 0; this.input.touchAimV.y = 0; this.input.touchShooting = false; }
                    this.touchAimNub.style.transform = `translate(${Math.min(stickLimit, Math.max(-stickLimit, dx))}px, ${Math.min(stickLimit, Math.max(-stickLimit, dy))}px)`;
                }
            }
        }
        handleTouchEnd(e) { /* ... (code unchanged) ... */
             e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                if (touch.identifier === this.input.touchMoveId) {
                    this.input.touchMoveId = null; this.input.touchMoveV.x = 0; this.input.touchMoveV.y = 0;
                    this.touchMoveNub.style.transform = 'translate(0,0)'; this.touchMoveStick.style.display = 'none';
                } else if (touch.identifier === this.input.touchAimId) {
                    this.input.touchAimId = null; this.input.touchShooting = false;
                    this.touchAimNub.style.transform = 'translate(0,0)'; this.touchAimStick.style.display = 'none';
                }
            }
        }
        setupInputListeners() { /* ... (code modified to use myPlayerId) ... */
            window.addEventListener('keydown', (e) => this.input.keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => this.input.keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousedown', () => this.input.shooting = true);
            window.addEventListener('mouseup', () => this.input.shooting = false);
            window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                window.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                window.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                window.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                window.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });
                this.touchReloadBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const human = this.playerMap.get(this.myPlayerId);
                    if (human) human.startReload();
                });
            }
            window.addEventListener('gamepadconnected', (e) => { this.input.gamepad = e.gamepad; });
            window.addEventListener('gamepaddisconnected', (e) => { if (this.input.gamepad && this.input.gamepad.index === e.gamepad.index) this.input.gamepad = null; });
        }
    }
    
    // --- 6. Initialization (MODIFIED) ---
    playSoloBtn.addEventListener('click', () => {
        game = new Game('solo');
    });
    createGameBtn.addEventListener('click', () => {
        createGameBtn.disabled = true;
        joinGameBtn.disabled = true;
        game = new Game('host');
    });
    joinGameBtn.addEventListener('click', () => {
        const remoteId = joinIdInput.value.trim();
        if (remoteId) {
            createGameBtn.disabled = true;
            joinGameBtn.disabled = true;
            game = new Game('client', remoteId);
        } else {
            alert('Please enter a valid friend ID.');
        }
    });
    // The "Play Again" button just reloads the page to go back to the menu
    playAgainButton.addEventListener('click', () => window.location.reload());
    
})();
</script>
</body>
</html>